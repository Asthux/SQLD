**중요 데이터 유형**

- CHARACTER(s) : 고정 길이 문자열 정보 s는 기본 길이 1바이트, s만큼 최대 길이를 갖고 고정 길이를 가지고 있으므로 해당 할당된 변수값의 길이가 s보다 작을 경우 그 차이만큼 공간으로 채워진다.
- VARCHAR(s) : CHARACTER VARYING의 약자로 가변 길이 문자열 정보(Oracle은 VARCHAR2) s는 최소 길이 1바이트, s만큼의 최대 길이를 갖지만 가변 길이로 조정이 되기 때문에 해당 할당된 변수값의 바이트만 적용된다.
- NUMERIC : 정수, 실수 등 숫자정보 (Oracle은 NUMBER), Oracle은 처음에 전체 자리 수를 지정하고 그 다음 소수 부분의 자리 수를 지정한다(정수 6자리, 소수 2자리 인 경우, NUMBER(8(6+2),2)가 된다.)
- DATETIME : 날짜와 시각 정보 (Oracle은 DATE로 표현), Oracle은 1초 단위

**문자열 유형**

- VARCHAR유형은 가변 길이이므로 필요한 영역은 실제 데이터 크기뿐이다. 그렇기 때문에 길이가 다양한 칼럼과, 정의된 길이와 실제 데이터 길이에 차이가 있는 칼럼에 적합하다. 저장 측면에서도 CHAR 유형보다 작은 영역에 저장할 수 있으므로 장점이 있다.
- CHAR 유형은 문자열을 비교할 때 공백(BLANK)를 채워 비교하는 방법을 사용한다. 우선 짧은 쪽의 끝에 공백을 추가하여 2개의 데이터가 같은 길이가 되도록 한다. 그리고 앞에서부터 한 문자씩 비교한다. 그러나 VARCHAR 유형에서는 맨 처음부터 한 문자씩 비교하고 공백도 하나의 문자로 취급한다.

**테이블 생성 규칙**

- 객체를 의미할 수 있는 적절한 이름을 사용한다. 가능한 단수형을 권고
- 다른 테이블의 이름과 중복되지 않아야 한다
- 한 테이블 내에서 칼럼명이 중복되게 지정될 수 없다
- 테이블 이름을 지정하고 각 칼럼들은 "()" 괄호 로 묶어 지정한다
- 각 칼럼들은 콤마로 구분되고, 항상 끝은 세미콜론 ; 으로 끝난다
- 칼럼에 대해서는 다른 테이블까지 고려하여 데이터베이스 내에서는 일관성 있게 사용하는 것이 좋다(데이터 표준화 관점)
- 칼럼 뒤에 데이터 유형은 꼭 지정되어야 한다
- 테이블명과 칼럼명은 반드시 문자로 시작(숫자 X)해야 하고, 벤더별로 길이에 대한 한계가 있다
- 벤더에서 사전에 정의한 예약어(Reserved word)는 쓸 수 없다
- A-Z, a-z, 0-9, _, $, # 문자만 허용된다
- 특수 문자 '-'는 허용되지 않음

**제약 조건 종류**

- PRIMARY KEY(기본키) : 테이블에 저장된 행 데이터를 고유하게 식별하기 위한 기본키를 정의한다

  하나의 테이블에 하나의 기본키 제약만 정의할 수 있다

  기본키 제약을 작성하면 DBMS는 자동으로 UNIQUE 인덱스를 작성하며, 기본키를 구성하는 칼럼에는 NULL을 입력할 수는 없다

  결국 기본키 제약 = 고유키 제약 & NOT NULL 제약이 된다

- UNIQUE(고유키) : 테이블에 저장된 행 데이터를 고유하게 식별하기 위한 기본키를 정의한다. 단, NULL은 고유키 제약의 대상이 아니므로, NULL 값을 가진 행이 여러 개가 있더라도 고유키 제약 위반이 되지 않는다.

- NOT NULL : NULL값의 입력을 금지한다. 디폴트 상태에서는 모든 칼럼에서 NULL을 허가하고 있지만, 이 제약을 지정함으로써 해당 칼럼은 입력 필수가 된다. NOT NULL을 CHECK의 일부분으로 이해할 수도 있다.

- CHECK : 입력할 수 있는 값의 범위 등을 제한한다. CHECK 제약으로는 TRUE or FALSE로 평가할 수 있는 논리식을 지정한다.

- FOREIGN KEY(외래키) : 관계형 데이터베이스에서 테이블 간의 관계를 정의하기 위해 기본키를 다른 테이블의 외래키로 복사하는 경우 외래키가 생성된다. 외래키 지정시 참조 무결성 제약 옵션을 선택할 수 있다.

**제약 조건**

- 제약조건은 칼럼의 데이터 유형 뒤에 NOT NULL을 정의한 사례와 같은 칼럼 LEVEL 방식과, PK,FK 같은 테이블 생성 마지막에 모든 제약조건을 기술하는 테이블 LEVEL 방식이 있다. 하나의 SQL 문장에서 두가지 방식은 혼용해서 사용할 수 있으며 같은 기능을 가지고 있다. 또한 별도의 DDL 문장으로 수행할 수도 있다.
- NULL은 공백(BLANK, ASCII 코드 32번)이나 숫자 0(ZERO, ASCII 48)과는 전혀 다른 값이며, 조건에 맞는 데이터가 없을 때의 공집합과도 다르다. 'NULL'은 아직 정의되지 않은 미지의 값이거나 현재 데이터를 입력하지 못하는 경우를 의미한다
- 데이터 입력 시에 칼럼의 값이 지정되어 있지 않을 경우 기본값(DEFAULT)을 사전에 설정할 수 있다. 데이터 입력시 명시된 값을 지정하지 않은 경우에 NULL 값이 입력되고, DEFAULT 값을 정의했다면 해당 칼럼에 NULL 값이 입력되지 않고 사전에 정의된 기본 값이 자동으로 입력된다.

**SELECT 문장을 통한 테이블 생성 사례**

- DML 문장 중에 SELECT 문장을 활용해서 테이블 생성할(CTAS : Create Table ~ As Select ~)수 있는 방법이 있다. 기존 테이블을 이용한 CTAS 방법을 이용할 수 있다면 칼럼별로 데이터 유형을 다시 재정의하지 않아도 되는 장점이 있다.
- CTAS 기법 사용시 주의할 점은 기존 테이블의 제약조건 중에 NOT NULL만 새로운 복제 테이블에 적용이 되고, 기본키, 고유키, 외래키, CHECK 등의 다른 제약조건은 없어진다는 점이다. 제약 조건을 추가하기 위해서는 뒤에 나오는 ALTER TABLE 기능을 사용해야 한다.

**ALTER TABLE**

- ADD COLUMN : 주의할 것은 새롭게 추가된 칼럼은 테이블의 마지막 칼럼이 되며 칼럼의 위치를 지정할 수는 없다.![스크린샷 2023-10-27 오후 5.20.21](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-27 오후 5.20.21.png)
- DROP COLUMN : 한 번에 하나의 칼럼만 삭제 가능하며, 칼럼 삭제 후 최소 하나 이상의 칼럼이 테이블에 존재해야 한다. 주의할 부분은 한 번 삭제된 칼럼은 복구가 불가능하다.![스크린샷 2023-10-27 오후 5.21.10](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-27 오후 5.21.10.png)
- MODIFY COLUMN : 테이블에 존재하는 칼럼에 대해서 MODIFY COLUMN명령을 이용해 칼럼의 데이터 유형, 디폴트(DEAFAULT) 값, NOT NULL 제약조건에 대한 변경을 포함할 수 있다.![스크린샷 2023-10-27 오후 5.22.26](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-27 오후 5.22.26.png)
- RENAME COLUMN : RENAME COLUMN으로 칼럼명이 변경되면, 해당 칼럼과 관계된 제약조건에 대해서도 자동으로 변경되는 장점이 있지만, ADD/DROP COLUMN 기능처럼 ANSI/ISO에 명시되어 있는 기능이 아니고 Oracle 등 일부 DBMS에서만 지원하는 기능이다.![스크린샷 2023-10-27 오후 5.23.38](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-27 오후 5.23.38.png)
- DROP CONSTRAINT : 테이블 생성 시 부여했던 제약조건을 삭제하는 명령어 형태는 다음과 같다.![스크린샷 2023-10-27 오후 5.24.13](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-27 오후 5.24.13.png)
- ADD CONSTRAINT : 테이블 생성 이후에 필요에 의해서 제약조건을 추가할 수 있다.![스크린샷 2023-10-27 오후 5.39.41](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-27 오후 5.39.41.png)
- RENAME TABLE : RENAME 명령어를 사용하여 테이블의 이름을 변경할 수 있다.![스크린샷 2023-10-27 오후 5.40.07](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-27 오후 5.40.07.png)
- DROP TABLE : 테이블을 잘못 만들었거나 테이블이 더 이상 필요없을 경우 해당 테이블을 삭제해야 한다. ![스크린샷 2023-10-27 오후 5.40.34](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-27 오후 5.40.34.png)
- TRUNCATE TABLE : 테이블 자체가 삭제되는 것이 아니고, 해당 테이블에 들어있던 모든 행들이 제거되고 저장공간을 재사용 가능하도록 해제된다. 테이블 구조를 완전히 삭제하기 위해서는 DROP TABLE을 실행해야 된다. ![스크린샷 2023-10-27 오후 5.41.40](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-27 오후 5.41.40.png)

**TRUNCATE TABLE**

- DROP TABLE의 경우는 테이블 자체가 없어지기 때문에 테이블 구조를 확인할 수 없다. 반면 TRUNCATE TABLE의 경우는 테이블 구조는 그대로 유지한 채 데이터만 전부 삭제하는 기능이다

- TRUNCATE는 데이터 구조의 변경 없이 테이블의 데이터를 일괄 삭제하는 명령어로 DML로 분류할 수도 있지만, 내부 처리 방식이나 Auto Commit 특성 등으로 인해 DDL로 분류하였다

- 테이블에 있는 데이터를 삭제하는 명령어는 TRUNCATE TABLE 명령어 이외에도 다음 DML 절에서 살펴볼 DELETE 명령어가 있다. 그러나 DELETE와 TRUNCATE는 처리하는 방식 자체가 다르다

- 테이블의 전체 데이터를 삭제하는 경우, 시스템 활용 측면에서는 DELETE TABLE 보다는 시스템 부하가 적은 TRUNCATE TABLE을 권고한다. 단, TRUNCATE TABLE의 경우 정상적인 복구가 불가능하므로 주의해야 한다

  