**트랜잭션**

- 트랜잭션은 데이터베이스의 <u>논리적 연산단위</u>
- 트랜잭션(TRANSACTION)이란 밀접히 관련되어 분리될 수 없는 한 개 이상의 데이터베이스 조작
- 하나의 트랜잭션에는 하나 이상의 SQL 문장이 포함
- 트랜잭션은 의미적으로 분할할 수 없는 최소의 단위
- 그렇기 때문에 <u>전부 적용</u>하거나 <u>전부 취소</u>한다.
- ALL or NOTHING

**트랜잭션 특성**

- 원자성 : 모두 성공적으로 실행되던지 / 전혀 실행되지 않은 상태로 남아있어야 함
- 일관성 : 트랜잭션이 실행 되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 실행 후에도 데이터베이스의 내용에 잘못이 있으면 안된다
- 고립성 : 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다
- 지속성 : 트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다.
- 트랜잭션의 특성(특히 원자성)을 충족하기 위해 데이터베이스는 다양한 레벨의 잠금(LOCK) 기능을 제공하고 있는데, 잠금은 기본적으로 트랜잭션이 수행하는 동안 특정 데이터에 대해서 다른 트랜잭션이 동시에 접근하지 못하도록 제한하는 기법이다

**TCL**

- 트랜잭션을 컨트롤 하는 TCL(TRANSACTION CONTROL LANGUAGE)
  - COMMIT(커밋) : 변경된 데이터를 데이터베이스에 영구적으로 반영하라
  - ROLLBACK(롤백) : 변경된 데이터가 문제가 있으니 변경 전 데이터로 복귀하라
  - SAVEPOINT(저장점) : 데이터 변경을 사전에 지정한 저장점까지만 롤백하라
- COMMIT과 ROLLBACK을 사용함으로써 다음과 같은 효과를 볼 수 있다
  - 데이터 무결성 보장
  - 영구적인 변경을 하기 전에 데이터의 변경 사항 확인 가능
  - 논리적으로 연관된 작업을 그룹핑하여 처리 가능
- COMMIT이나 ROLLBACK(트랜잭션 철회) 이전 데이터 상태는 다음과 같다
  - 현재 사용자는 SELECT 문장으로 결과를 확인 가능하다
  - 다른 사용자는 현재 사용자가 수행한 명령의 결과를 볼 수 없다
  - 변경된 행은 잠금(LOCKING)이 설정되어 다른 사용자가 변경할 수 없다

**SAVEPOINT**

- 트랜잭션에 포함된 전체 작업(스텝)을 롤백하는 것이 아니라 현 시점에서 미리 지정한 SAVEPOINT까지 트랜잭션의 일부만 롤백할 수 있다
- 복수의 저장점을 정의할 수 있으며, 동일이름으로 저장점을 정의했을 때는 나중에 정의한 저장점이 유효하다.
- ![스크린샷 2023-10-30 오후 4.59.05](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-30 오후 4.59.05.png)
- ![스크린샷 2023-10-30 오후 4.59.55](/Users/asthu/Library/Application Support/typora-user-images/스크린샷 2023-10-30 오후 4.59.55.png)

**COMMIT과 ROLLBACK**

- 트랜잭션은 트랜잭션의 대상이 되는 SQL문을 실행하면 자동으로 시작되고, COMMIT과 또는 ROLLBACK을 실행한 시점에서 종료된다
- COMMIT과 ROLLBACK을 사용함으로써 다음과 같은 효과를 볼 수 있다
  - 논리적으로 연관된 작업을 그룹핑하여 처리 가능
  - 영구적인 변경을 하기 전에 데이터의 변경 사항 확인 가능
  - 데이터 무결성 보장
- 자동 커밋이 발생하는 경우
  - CREATE, ALTER, DROP, RENAME, TRUNCATE TABLE 등 DDL 문장을 실행하면 그 전후 시점에 자동으로 커밋된다. 부연하면, DML 문장 이후에 커밋 없어도 DDL 문장이 실행되면 DDL 수행 전에 자동으로 커밋된다
  - 데이터베이스를 정상적으로 접속 종료하면 트랜잭션이 자동 커밋된다
  - 애플리케이션의 이상 종료로 데이터베이스와의 접속이 단절되었을 때는 트랜잭션이 자동 롤백된다.

**SQL SERVER COMMIT 모드**

- Oracle은 DML을 실행하는 경우 DBMS가 트랜잭션을 내부적으로 실행하며 DML 문장 수행 후 사용자가 임의로 COMMIT 혹은 ROLLBACK을 수행해 주어야 트랜잭션이 종료된다
- SQL Server는 기본적으로 AUTO COMMIT 모드이기 때문에 DML 수행 후 사용자가 COMMIT이나 ROLLBACK을 처리할 필요가 없다. DML 구문이 성공하면 자동으로 COMMIT이 되고 오류가 발생할 경우 자동으로 ROLLBACK 처리된다

**SQL Server 3가지 COMMIT 방식**

- AUTO COMMIT : SQL Server의 기본방식이며, DML, DDL 단위 SQL을 수행할 때마다 DBMS가 트랜잭션을 컨트롤하는 방식이다. 명령어가 성공적으로 수행되면 자동으로 COMMIT을 수행하고 오류가 발생하면 자동으로 ROLLBACK을 수행한다
- 암시적 트랜잭션 : Oracle과 같은 방식으로 처리된다. 즉, 트랜잭션의 시작은 DBMS가 처리하고 트랜잭션의 끝은 사용자가 명시적으로 COMMIT 또는 ROLLBACK으로 처리한다. 인스턴스 단위 또는 세션 단위로 설정할 수 있다. 인스턴스 단위로 설정하려면 서버 속성 창의 연결화면에서 기본연결 옵션 중 암시적 트랜잭션에 체크를 해주면 된다. 세션 단위로 설정하기 위해서는 세션 옵션 중 SET IMPLICIT TRANSACTION ON을 사용하면 된다
- 명시적 트랜잭션 : 트랜잭션의 시작과 끝을 사용자가 명시적으로 지정하는 방식이다. BEGIN TRANSACTION (BEGIN TRAN 구문도 가능)으로 트랜잭션을 시작하고 COMMIT TRANSACTION (TRANSACTION은 생략 가능) 또는 ROLLBACK TRANSACTION (TRANSACTION은 생략 가능)으로 트랜잭션을 종료한다. ROLLBACK 구문을 만나면 최초의 BEGIN TRANSACTIPN 시점까지 모두 ROLLBACK이 수행된다.